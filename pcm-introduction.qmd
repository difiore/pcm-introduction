---
title: "A Gentle Introduction to PCM"
format:
  html:
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Libraries to Install and Load

Most are available on CRAN, but for {ggtree}, it may be necessary to to do the following:

```{r}
#| eval: false
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("ggtree")
```

```{r}
library(tidyverse)
library(ape)
library(phytools)
library(ggtree)
library(broom)
library(nlme)
```

The following packages are also also useful for PCM: {geiger}, {phangorn}, {treedata.table}

## Plotting a Phylogeny

It is easy to load in phylogenetic trees saved as text files in Newick or Nexus format...

Newick format uses nested parentheses to represent the nesting of clades. Commas separate sister nodes or branches, and the entire tree is terminated with a semicolon. Branch lengths leading to a given node can be indicated following a colon.

Nexus format is a more comprehensive format that can include sequence alignments or character state data in addition to one or more phylogenetic trees in its "TREES" block. Within that block, trees are represented in Newick format.

### Example 1 - Kuderna et al 2024
```{r}
tree_file <- "Kuderna et al S4 fossil calibrated time tree.newick"
tree <- read.tree(tree_file)
is.rooted.phylo(tree)
is.binary(tree)

## quick plot
plot.phylo(tree, type = "cladogram", cex = 0.6)
## or type = "cladogram" or "phylogram"

## plot with ggplot
p <- ggtree(tree, layout = "fan") +
  geom_tiplab(aes(label=label), size=2)
p
```

### Example 2 - Lewis et al 2023
```{r}
tree_file <- "Lewis et al figure S1 tree.nexus"
tree <- read.nexus(tree_file)
par(mar = c(2, 1, 1, 1)) # set bottom, left, top, and right margins
plot.phylo(tree, type = "phylogram", cex = 0.6, direction = "rightwards")
axisPhylo(backward = TRUE) # compare to lewis et al figure S1
```

### Example 3 - Springer et al 2015
```{r}
tree_file <- "Springer et al S2 timetree with autocorrelated rates and hard-bounded constraints.newick"
tree <- read.tree(tree_file)
is.rooted.phylo(tree)
is.binary(tree)
# plot full tree
p <- ggtree(tree, layout = "fan") +
  geom_tiplab(aes(label=label), size=2)
p
# prune the tree to only species used by Lewis et al 2023
d <- read_csv("Lewis et al table S1.csv", col_names = TRUE)
taxa <- d$Species
pruned_tree <- drop.tip(tree, tip = setdiff(tree$tip.label, taxa))
# plot the pruned tree
p <- ggtree(pruned_tree, layout = "fan") +
  geom_tiplab(aes(label=label), size = 2)
p
plot.phylo(pruned_tree, type = "fan", cex = 0.6)
```

## Effect of Phylogenetic Structure

When we are interested in coevolution of traits or adaptive relationships of traits within a group of organisms, it is critical to recognize that closely related species may share trait values because of shared evolutionary history, NOT because of adaptation.

To explore this, let's simulate *random evolution* of two metric characters on this tree and then look at the relationship between them using regression... (the values for a and sig2 in the code below are arbitrary, just to give us a wider range of trait values)

```{r}
set.seed(25)
bodysize <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
homerange <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
d <- tibble(bodysize = bodysize, homerange = homerange)
ggplot(d, aes(x = bodysize, y= homerange)) +
  geom_point() +
  geom_smooth(method = "lm")
# there is a negative association between these two characters... but they have evolved INDEPENDENTLY!
m <- lm(homerange ~ bodysize, d)
summary(m)

set.seed(30)
bodysize <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
homerange <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
d <- tibble(bodysize = bodysize, homerange = homerange)
ggplot(d, aes(x = bodysize, y= homerange)) +
  geom_point() +
  geom_smooth(method = "lm")
# there is a positive association between these two characters... but they have evolved INDEPENDENTLY!
m <- lm(homerange ~ bodysize, d)
summary(m)
```

How about if we do this MANY times? A simulation...

```{r}
sim <- tibble(est = numeric(), p = numeric(), seed = numeric())
for (i in 1:100){
  set.seed(i)
  bodysize <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
  homerange <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
  d <- tibble(bodysize = bodysize, homerange = homerange)
  m <- lm(homerange ~ bodysize, d)
  est <- m |> tidy() |>
       filter(term == "bodysize") |>
       select(estimate) |>
       pull()
  p <- m |> tidy() |>
       filter(term == "bodysize") |>
       select(p.value) |>
       pull()
  res <- tibble(est = est, p = p, seed = i)
  sim <- bind_rows(sim, res)
}
par(mar = c(2, 2, 2, 2))
hist(sim$est, breaks = seq(-1.2, 1.2, 0.2), main = "Histogram of coefficient estimates")
hist(sim$p, breaks = seq(0,1, by = 0.05), main = "Histogram of p values")
```

Takehome? Many simulations wind up with p values of less than 0.05 for traits that are evolving independently of one another, based just on the phylogenetic tree structure!

Let's pull out the seed with the highest positive estimate from our simulation...

```{r}
seed <- sim |>
        arrange(desc(est)) |>
        slice_head(n = 1) |>
        pull(seed)
set.seed(seed)
bodysize <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
homerange <- fastBM(pruned_tree, a = 100, mu = 0, sig2 = 100)
d <- tibble(bodysize = bodysize, homerange = homerange)
ggplot(d, aes(x = bodysize, y= homerange)) +
  geom_point() +
  geom_smooth(method = "lm")
m <- lm(homerange ~ bodysize, d)
summary(m)
```

Note again that this steep positive correlation is due entirely to effects of phylogeny! Here, species data are not independent of one another...

## Running a Phylogenetic Independent Contrasts Analysis

If we are interested in accounting for the effects of phylogeny on the interdependence of our data points, how might we control for this? 

One way is to use CONTRASTS at each internal node, which are independent of one another. For a bifurcating tree with N taxa, the are N-1 independent contrasts.

Instead of use ordinary least square (OLS) regression where data points are each taxon's trait values, we can run OLS where each observation is the CONTRAST at each internal node (and where we force the regression through the origin).

```{r}
contrasts.bodysize <- pic(bodysize, pruned_tree) # use the pic function to calculate independent contrasts
contrasts.homerange <- pic(homerange, pruned_tree)
d <- tibble(contrasts.bodysize = contrasts.bodysize, contrasts.homerange = contrasts.homerange)
ggplot(d, aes(x = contrasts.bodysize, y = contrasts.homerange)) +
  geom_point() +
  geom_smooth(method = "lm")
pic.m <- lm(contrasts.homerange ~ contrasts.bodysize + 0) # include the term + 0 to force the regression through the origin, i.e., to not calculate an intercept term
summary(pic.m)
# there is no relationship between the contrasts...
```

Takehome? It is critical to take phylogeny into account otherwise we risk concluding that adaptation or coevolution have occurred when the relationship seen between two traits of interest is due to phylogeny.

## Phylogenetic Generalized Least Squares

The PIC method is fine for looking at two metric variables, but often we are interested in more than two traits and/or at traits that are non-metric. PGLS is more flexible approach. PIC is also just a specific application of PGLS.

First, we will do PIC on a new dataset and address the question, how is *eye size* related to *body size* in primates? This data set uses "Orbit_area" as a measure of eye size and "Skull_length" as a measure of body size.

```{r}
d <- read_csv("primateEyes.csv", col_names = TRUE)
head(d)
tree <- read.tree("primateEyes.phy")
p <- ggtree(tree, layout = "fan") +
  geom_tiplab(aes(label=label), size=2)
p
ggplot(d, aes(x = log(Skull_length), y=log(Orbit_area))) +
  geom_point() +
  geom_smooth(method = "lm")
```

Ordinary least squares regression...

```{r}
m <- lm(log(Orbit_area) ~ log(Skull_length), data = d)
summary(m)
```

Now PIC...

```{r}
orbit.area <- d$Orbit_area
names(orbit.area) <- d$Genus_species
skull.length <- d$Skull_length
names(skull.length) <- d$Genus_species
pic.orbit.area <- pic(log(orbit.area), tree)
pic.skull.length <- pic(log(skull.length), tree)
d <- tibble(contrasts.orbit.area = pic.orbit.area, contrasts.skull.length = pic.skull.length)
ggplot(d, aes(x = contrasts.skull.length, y= contrasts.orbit.area)) +
  geom_point() +
  geom_smooth(method = "lm")
pic.m <- lm(pic.orbit.area ~ pic.skull.length + 0) # +0 to force the regression through the origin
summary(pic.m)
```

For this dataset, a positive relationship between orbit size and bidy size remains when we use contrasts.

To now do PGLS, now, we need to convert our TREE to a correlation structure object.

There are different ways to do this, but one simple approach is to assume that the correlation between the residual errors of any pair of species is proportional to the distance on the tree back to the common ancestor of that pair. [There are alternative models to derive the correlation structure that imagine more complex forms of evolutionary change.]

```{r}
# read in data again
d <- read_csv("primateEyes.csv", col_names = TRUE)
taxa <- d$Genus_species
corBM <- corBrownian(phy = tree, form = ~taxa)
corBM
pgls.m <- gls(log(Orbit_area)~log(Skull_length), data = d, correlation = corBM) # note that we do not need to force the regression through the origin
summary(pgls.m)
```

Compare the results for PGLS and PIC for this same dataset and analysis. Note that they yield the same results for the estimate and the p value. PIC is a specialized case of PGLS.

More generally, with PGLS, we can include additional covariates in our modeling.

For example, using this dataset, we can now see if *eye size* is related to both *body size* and *activity pattern* using, essentially, ANCOVA.

```{r}
pgls.m <- gls(log(Orbit_area)~log(Skull_length) + Activity_pattern, data = d, correlation = corBM)
anova(pgls.m)
```

Based on the ANOVA table, when *body size* is taken into account, mean *orbit size* is different for different levels of *activity pattern*, and when *activity pattern* is taken into account, *orbit size* is positively related to *body size*.

We can visualize these patterns using the following code...

```{r}
# create a grid of data to put into the pgls model to predict orbit size from body size and activity pattern...
newdata <- expand.grid(
  Skull_length = seq(min(d$Skull_length), max(d$Skull_length), length.out = 100),
  Activity_pattern = levels(as.factor(d$Activity_pattern))
)
newdata$prediction <- predict(pgls.m, newdata)
```

And then plot the original data and regression lines for each level of *activity pattern*...

```{r}
ggplot(d, aes(x = log(Skull_length), y = log(Orbit_area), color = Activity_pattern)) +
  geom_point(size = 3) +
  geom_line(data = newdata, aes(y = prediction), linewidth = 1) +
  theme_minimal(base_size = 14) +
  labs(
    x = "log(Skull length)",
    y = "log(Orbit area)",
    color = "Activity pattern",
    title = "PGLS results: Orbit area vs Skull length"
  )
```

## Ancestral State Reconstruction

Let's return to the Lewis et al data we looked at before and try to replicate their Ancestral State Reconstruction results.

```{r}
tree_file <- "Springer et al S2 timetree with autocorrelated rates and hard-bounded constraints.newick"
tree <- read.tree(tree_file)
d <- read_csv("Lewis et al table S1.csv", col_names = TRUE)
taxa <- d$Species
d$Dominance <- as.factor(d$Dominance)
par(mar = c(2, 1, 1, 1)) 
# prune the tree to only species used by Lewis et al 2023
pruned_tree <- drop.tip(tree, tip = setdiff(tree$tip.label, taxa))
plot.phylo(pruned_tree, cex = 0.6)

colors <- c("green", "blue", "red")
state_names <- c("codominant", "female", "male")

# plot the pruned tree with character states on tips
p <- ggtree(pruned_tree, layout = "fan") %<+% d +
  geom_tippoint(aes(color = Dominance), size = 3) +
  scale_color_manual(values = colors) +
  geom_tiplab(aes(label=label), offset = 0.02, size=2)
p
```

### Mk Model of Discrete Character Evolution

Dominant model for the evolution of discrete characters on a phylogeny is the Mk model (continuous time, discrete k, Markov chain model).

```{r}
# define data to analyze
character_data <- d$Dominance
names(character_data) <- d$Species
tree <- pruned_tree
tree$node.label <- 1:Nnode(tree) + length(tree$tip.label)
# Run Mk Ancestral State Reconstruction ----
## equal rates model
fitER <- fitMk(tree, character_data, model = "ER")
## all rates different model
fitARD <- fitMk(tree, character_data, model = "ARD")
## symmetric rates model
fitSYM <- fitMk(tree, character_data, model = "SYM")
aov <- anova(fitER, fitARD, fitSYM) # compare models -- which best fits observed patterns of states at tips
bestMk <- rownames(aov[which.min(aov$AIC),])
Mk <- ancr(aov, type = "marginal", weighted = FALSE, tips = TRUE)
# with weighted = FALSE, ancr() uses the best supported model for ASR; with weighted = TRUE, models are weighted based on weight
Mk_probs <- Mk$ace # all nodes
Mk_node_pies <- Mk_probs[(length(tree$tip.label) + 1):(length(tree$tip.label) + tree$Nnode), ] # subset for just internal nodes
Mk_tip_pies <- Mk_probs[1:length(tree$tip.label), ] # subset for just tips

plot.phylo(tree, type = "cladogram", cex = 0.6, main = "Mk Model ASR")
#### add pie charts for ancestral states at internal nodes
nodelabels(
    pie = Mk_node_pies,
    piecol = colors,
    cex = 0.4
)
legend("topleft",
   legend = state_names,
   fill = colors,
   title = "Character States")
#### add pie charts for tips
#tiplabels(
#   pie = Mk_tip_pies,
#   piecol = colors,
#   cex = 0.4
#)
```

### Stochastic Character Mapping for ASR

```{r}
#### Run SCM Ancestral State Reconstruction ----
nsim <- 100  # Number of stochastic maps to generate
scmER <- make.simmap(tree, character_data, model = "ER", nsim = nsim)
# or
# scmARD <- make.simmap(tree, character_data, model = "ARD", nsim = nsim)
# or
# scmSYM <- make.simmap(tree, character_data, model = "SYM", nsim = nsim)

#### summarize the stochastic maps
summary_scm <- summary(scmER)

#### extract posterior probabilities and pies for internal nodes and tips
scm_probs <- summary_scm$ace
scm_node_pies <- scm_probs[1:tree$Nnode, ]
scm_tip_pies <- summary_scm$tips

#### Plotting Results ----
plot.phylo(tree, type = "cladogram", cex = 0.6, main = "Stochastic Character Mapping ASR")
#### add pie charts for ancestral states at internal nodes
nodelabels(
    pie = scm_node_pies,
    piecol = colors,
    cex = 0.4
)
legend("topleft",
   legend = state_names,
   fill = colors,
   title = "Character States")
#### add pie charts for tips
#tiplabels(
#   pie = scm_tip_pies,
#   piecol = colors,
#   cex = 0.4
#)
```
